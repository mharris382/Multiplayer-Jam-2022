#unity-api #api 

# UnityEngine.Mathf
## Static Properties
[Deg2Rad](https://docs.unity3d.com/ScriptReference/Mathf.Deg2Rad.html)Degrees-to-radians conversion constant (Read Only).
[Epsilon](https://docs.unity3d.com/ScriptReference/Mathf.Epsilon.html)A tiny floating point value (Read Only).
[Infinity](https://docs.unity3d.com/ScriptReference/Mathf.Infinity.html)A representation of positive infinity (Read Only).
[NegativeInfinity](https://docs.unity3d.com/ScriptReference/Mathf.NegativeInfinity.html)A representation of negative infinity (Read Only).
[PI](https://docs.unity3d.com/ScriptReference/Mathf.PI.html)The well-known 3.14159265358979... value (Read Only).
[Rad2Deg](https://docs.unity3d.com/ScriptReference/Mathf.Rad2Deg.html) Radians-to-degrees conversion constant (Read Only).

## Static Methods
[Abs](https://docs.unity3d.com/ScriptReference/Mathf.Abs.html)Returns the absolute value of f.
[Acos](https://docs.unity3d.com/ScriptReference/Mathf.Acos.html)Returns the arc-cosine of f - the angle in radians whose cosine is f.
[Approximately](https://docs.unity3d.com/ScriptReference/Mathf.Approximately.html)Compares two floating point values and returns true if they are similar.

[Asin](https://docs.unity3d.com/ScriptReference/Mathf.Asin.html)Returns the arc-sine of f - the angle in radians whose sine is f.

[Atan](https://docs.unity3d.com/ScriptReference/Mathf.Atan.html)Returns the arc-tangent of f - the angle in radians whose tangent is f.

[Atan2](https://docs.unity3d.com/ScriptReference/Mathf.Atan2.html)Returns the angle in radians whose Tan is y/x.

[Ceil](https://docs.unity3d.com/ScriptReference/Mathf.Ceil.html)Returns the smallest integer greater to or equal to f.

[CeilToInt](https://docs.unity3d.com/ScriptReference/Mathf.CeilToInt.html)Returns the smallest integer greater to or equal to f.

[Clamp](https://docs.unity3d.com/ScriptReference/Mathf.Clamp.html)Clamps the given value between the given minimum float and maximum float values. Returns the given value if it is within the minimum and maximum range.

[Clamp01](https://docs.unity3d.com/ScriptReference/Mathf.Clamp01.html)Clamps value between 0 and 1 and returns value.

[ClosestPowerOfTwo](https://docs.unity3d.com/ScriptReference/Mathf.ClosestPowerOfTwo.html)Returns the closest power of two value.

[CorrelatedColorTemperatureToRGB](https://docs.unity3d.com/ScriptReference/Mathf.CorrelatedColorTemperatureToRGB.html)Convert a color temperature in Kelvin to RGB color.

[Cos](https://docs.unity3d.com/ScriptReference/Mathf.Cos.html)Returns the cosine of angle f.

[DeltaAngle](https://docs.unity3d.com/ScriptReference/Mathf.DeltaAngle.html)Calculates the shortest difference between two given angles given in degrees.

[Exp](https://docs.unity3d.com/ScriptReference/Mathf.Exp.html)Returns e raised to the specified power.

[FloatToHalf](https://docs.unity3d.com/ScriptReference/Mathf.FloatToHalf.html)Encode a floating point value into a 16-bit representation.

[Floor](https://docs.unity3d.com/ScriptReference/Mathf.Floor.html)Returns the largest integer smaller than or equal to f.

[FloorToInt](https://docs.unity3d.com/ScriptReference/Mathf.FloorToInt.html)Returns the largest integer smaller to or equal to f.

[GammaToLinearSpace](https://docs.unity3d.com/ScriptReference/Mathf.GammaToLinearSpace.html)Converts the given value from gamma (sRGB) to linear color space.

[HalfToFloat](https://docs.unity3d.com/ScriptReference/Mathf.HalfToFloat.html)Convert a half precision float to a 32-bit floating point value.

[InverseLerp](https://docs.unity3d.com/ScriptReference/Mathf.InverseLerp.html)Determines where a value lies between two points.

[IsPowerOfTwo](https://docs.unity3d.com/ScriptReference/Mathf.IsPowerOfTwo.html)Returns true if the value is power of two.

[Lerp](https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html)Linearly interpolates between a and b by t.

[LerpAngle](https://docs.unity3d.com/ScriptReference/Mathf.LerpAngle.html)Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.

[LerpUnclamped](https://docs.unity3d.com/ScriptReference/Mathf.LerpUnclamped.html)Linearly interpolates between a and b by t with no limit to t.

[LinearToGammaSpace](https://docs.unity3d.com/ScriptReference/Mathf.LinearToGammaSpace.html)Converts the given value from linear to gamma (sRGB) color space.

[Log](https://docs.unity3d.com/ScriptReference/Mathf.Log.html)Returns the logarithm of a specified number in a specified base.

[Log10](https://docs.unity3d.com/ScriptReference/Mathf.Log10.html)Returns the base 10 logarithm of a specified number.

[Max](https://docs.unity3d.com/ScriptReference/Mathf.Max.html)Returns largest of two or more values.

[Min](https://docs.unity3d.com/ScriptReference/Mathf.Min.html)Returns the smallest of two or more values.

[MoveTowards](https://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html)Moves a value current towards target.

[MoveTowardsAngle](https://docs.unity3d.com/ScriptReference/Mathf.MoveTowardsAngle.html)Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.

[NextPowerOfTwo](https://docs.unity3d.com/ScriptReference/Mathf.NextPowerOfTwo.html)Returns the next power of two that is equal to, or greater than, the argument.

[PerlinNoise](https://docs.unity3d.com/ScriptReference/Mathf.PerlinNoise.html)Generate 2D Perlin noise.

[PingPong](https://docs.unity3d.com/ScriptReference/Mathf.PingPong.html)PingPong returns a value that will increment and decrement between the value 0 and length.

[Pow](https://docs.unity3d.com/ScriptReference/Mathf.Pow.html)Returns f raised to power p.

[Repeat](https://docs.unity3d.com/ScriptReference/Mathf.Repeat.html)Loops the value t, so that it is never larger than length and never smaller than 0.

[Round](https://docs.unity3d.com/ScriptReference/Mathf.Round.html)Returns f rounded to the nearest integer.

[RoundToInt](https://docs.unity3d.com/ScriptReference/Mathf.RoundToInt.html)Returns f rounded to the nearest integer.

[Sign](https://docs.unity3d.com/ScriptReference/Mathf.Sign.html)Returns the sign of f.

[Sin](https://docs.unity3d.com/ScriptReference/Mathf.Sin.html)Returns the sine of angle f.

[SmoothDamp](https://docs.unity3d.com/ScriptReference/Mathf.SmoothDamp.html)Gradually changes a value towards a desired goal over time.

[SmoothDampAngle](https://docs.unity3d.com/ScriptReference/Mathf.SmoothDampAngle.html)Gradually changes an angle given in degrees towards a desired goal angle over time.

[SmoothStep](https://docs.unity3d.com/ScriptReference/Mathf.SmoothStep.html)Interpolates between min and max with smoothing at the limits.

[Sqrt](https://docs.unity3d.com/ScriptReference/Mathf.Sqrt.html)Returns square root of f.

[Tan](https://docs.unity3d.com/ScriptReference/Mathf.Tan.html)

Returns the tangent of angle f in radians.


# Godot.Mathf

## Constants

Name | Value | Description
---|----|-----
Tau | 6.283185f | The circle constant, the circumference of the unit circle in radians.
Pi | `3.141593f` | Constant that represents how many times the diameter of a circle its around its perimeter
Inf | `float.PositiveInfinity` | Positive infinity. For negative infinity, use <c>-Mathf.Inf</c>.
NaN | `float.NaN` | Not a Number "Not a Number", an invalid value. <c>NaN</c> has pecial properties, including   that it is not equal to itself. It is output by some nvalid operations,   such as dividing zero by zero.
Deg2Rad | 0.01745329f | private
Rad2Deg |  57.29578f | private
E | 2.718282f |
Epsilon | 1E-06f | A very small number used for float comparison with error tolerance. 1e-06 with single-precision floats, but 1e-14 if <c>REAL_T_IS_DOUBLE</c>.

# Static Methods
```cs
/// <summary>  
/// Returns the absolute value of <paramref name="s" /> (i.e. positive value).  
/// </summary>  
/// <param name="s">The input number.</param>  
/// <returns>The absolute value of <paramref name="s" />.</returns>  
public static int Abs(int s) => Math.Abs(s);  
  
/// <summary>  
/// Returns the absolute value of <paramref name="s" /> (i.e. positive value).  
/// </summary>  
/// <param name="s">The input number.</param>  
/// <returns>The absolute value of <paramref name="s" />.</returns>  
public static float Abs(float s) => Math.Abs(s);  
  
/// <summary>  
/// Returns the arc cosine of <paramref name="s" /> in radians.  
/// Use to get the angle of cosine <paramref name="s" />.  
/// </summary>  
/// <param name="s">The input cosine value. Must be on the range of -1.0 to 1.0.</param>  
/// <returns>  
/// An angle that would result in the given cosine value. On the range <c>0</c> to <c>Tau/2</c>.  
/// </returns>  
public static float Acos(float s) => (float) Math.Acos((double) s);  
  
/// <summary>  
/// Returns the arc sine of <paramref name="s" /> in radians.  
/// Use to get the angle of sine <paramref name="s" />.  
/// </summary>  
/// <param name="s">The input sine value. Must be on the range of -1.0 to 1.0.</param>  
/// <returns>  
/// An angle that would result in the given sine value. On the range <c>-Tau/4</c> to <c>Tau/4</c>.  
/// </returns>  
public static float Asin(float s) => (float) Math.Asin((double) s);  
  
/// <summary>  
/// Returns the arc tangent of <paramref name="s" /> in radians.  
/// Use to get the angle of tangent <paramref name="s" />.  
/// /// The method cannot know in which quadrant the angle should fall.  
/// See <see cref="M:Godot.Mathf.Atan2(System.Single,System.Single)" /> if you have both <c>y</c> and <c>x</c>.  
/// </summary>  
/// <param name="s">The input tangent value.</param>  
/// <returns>  
/// An angle that would result in the given tangent value. On the range <c>-Tau/4</c> to <c>Tau/4</c>.  
/// </returns>  
public static float Atan(float s) => (float) Math.Atan((double) s);  
  
/// <summary>  
/// Returns the arc tangent of <paramref name="y" /> and <paramref name="x" /> in radians.  
/// Use to get the angle of the tangent of <c>y/x</c>. To compute the value, the method takes into  
/// account the sign of both arguments in order to determine the quadrant.  
/// /// Important note: The Y coordinate comes first, by convention.  
/// </summary>  
/// <param name="y">The Y coordinate of the point to find the angle to.</param>  
/// <param name="x">The X coordinate of the point to find the angle to.</param>  
/// <returns>  
/// An angle that would result in the given tangent value. On the range <c>-Tau/2</c> to <c>Tau/2</c>.  
/// </returns>  
public static float Atan2(float y, float x) => (float) Math.Atan2((double) y, (double) x);  
  
/// <summary>  
/// Converts a 2D point expressed in the cartesian coordinate  
/// system (X and Y axis) to the polar coordinate system  
/// (a distance from the origin and an angle).  
/// </summary>  
/// <param name="x">The input X coordinate.</param>  
/// <param name="y">The input Y coordinate.</param>  
/// <returns>A <see cref="T:Godot.Vector2" /> with X representing the distance and Y representing the angle.</returns>  
public static Vector2 Cartesian2Polar(float x, float y) => new Vector2(Mathf.Sqrt((float) ((double) x * (double) x + (double) y * (double) y)), Mathf.Atan2(y, x));  
  
/// <summary>  
/// Rounds <paramref name="s" /> upward (towards positive infinity).  
/// </summary>  
/// <param name="s">The number to ceil.</param>  
/// <returns>The smallest whole number that is not less than <paramref name="s" />.</returns>  
public static float Ceil(float s) => (float) Math.Ceiling((double) s);  
  
/// <summary>  
/// Clamps a <paramref name="value" /> so that it is not less than <paramref name="min" />  
/// and not more than <paramref name="max" />.  
/// </summary>  
/// <param name="value">The value to clamp.</param>  
/// <param name="min">The minimum allowed value.</param>  
/// <param name="max">The maximum allowed value.</param>  
/// <returns>The clamped value.</returns>  
public static int Clamp(int value, int min, int max) => value < min ? min : (value > max ? max : value);  
  
/// <summary>  
/// Clamps a <paramref name="value" /> so that it is not less than <paramref name="min" />  
/// and not more than <paramref name="max" />.  
/// </summary>  
/// <param name="value">The value to clamp.</param>  
/// <param name="min">The minimum allowed value.</param>  
/// <param name="max">The maximum allowed value.</param>  
/// <returns>The clamped value.</returns>  
public static float Clamp(float value, float min, float max) => (double) value < (double) min ? min : ((double) value > (double) max ? max : value);  
  
/// <summary>  
/// Returns the cosine of angle <paramref name="s" /> in radians.  
/// </summary>  
/// <param name="s">The angle in radians.</param>  
/// <returns>The cosine of that angle.</returns>  
public static float Cos(float s) => (float) Math.Cos((double) s);  
  
/// <summary>  
/// Returns the hyperbolic cosine of angle <paramref name="s" /> in radians.  
/// </summary>  
/// <param name="s">The angle in radians.</param>  
/// <returns>The hyperbolic cosine of that angle.</returns>  
public static float Cosh(float s) => (float) Math.Cosh((double) s);  
  
/// <summary>Converts an angle expressed in degrees to radians.</summary>  
/// <param name="deg">An angle expressed in degrees.</param>  
/// <returns>The same angle expressed in radians.</returns>  
public static float Deg2Rad(float deg) => deg * ((float) Math.PI / 180f);  
  
/// <summary>  
/// Easing function, based on exponent. The <paramref name="curve" /> values are:  
/// <c>0</c> is constant, <c>1</c> is linear, <c>0</c> to <c>1</c> is ease-in, <c>1</c> or more is ease-out.  
/// Negative values are in-out/out-in.  
/// </summary>  
/// <param name="s">The value to ease.</param>  
/// <param name="curve">  
/// <c>0</c> is constant, <c>1</c> is linear, <c>0</c> to <c>1</c> is ease-in, <c>1</c> or more is ease-out.  
/// </param>  
/// <returns>The eased value.</returns>  
public static float Ease(float s, float curve)  
{  
  if ((double) s < 0.0)  
    s = 0.0f;  
  else if ((double) s > 1.0)  
    s = 1f;  
  if ((double) curve > 0.0)  
    return (double) curve < 1.0 ? 1f - Mathf.Pow(1f - s, 1f / curve) : Mathf.Pow(s, curve);  
  if ((double) curve >= 0.0)  
    return 0.0f;  
  return (double) s < 0.5 ? Mathf.Pow(s * 2f, -curve) * 0.5f : (float) ((1.0 - (double) Mathf.Pow((float) (1.0 - ((double) s - 0.5) * 2.0), -curve)) * 0.5 + 0.5);  
}  
  
/// <summary>  
/// The natural exponential function. It raises the mathematical  
/// constant <c>e</c> to the power of <paramref name="s" /> and returns it.  
/// </summary>  
/// <param name="s">The exponent to raise <c>e</c> to.</param>  
/// <returns><c>e</c> raised to the power of <paramref name="s" />.</returns>  
public static float Exp(float s) => (float) Math.Exp((double) s);  
  
/// <summary>  
/// Rounds <paramref name="s" /> downward (towards negative infinity).  
/// </summary>  
/// <param name="s">The number to floor.</param>  
/// <returns>The largest whole number that is not more than <paramref name="s" />.</returns>  
public static float Floor(float s) => (float) Math.Floor((double) s);  
  
/// <summary>  
/// Returns a normalized value considering the given range.  
/// This is the opposite of <see cref="M:Godot.Mathf.Lerp(System.Single,System.Single,System.Single)" />.  
/// </summary>  
/// <param name="from">The start value for interpolation.</param>  
/// <param name="to">The destination value for interpolation.</param>  
/// <param name="weight">The interpolated value.</param>  
/// <returns>  
/// The resulting value of the inverse interpolation.  
/// The returned value will be between 0.0 and 1.0 if <paramref name="weight" /> is  
/// between <paramref name="from" /> and <paramref name="to" /> (inclusive).  
/// </returns>  
public static float InverseLerp(float from, float to, float weight) => (float) (((double) weight - (double) from) / ((double) to - (double) from));  
  
/// <summary>  
/// Returns <see langword="true" /> if <paramref name="a" /> and <paramref name="b" /> are approximately equal  
/// to each other.  
/// The comparison is done using a tolerance calculation with <see cref="F:Godot.Mathf.Epsilon" />.  
/// </summary>  
/// <param name="a">One of the values.</param>  
/// <param name="b">The other value.</param>  
/// <returns>A <see langword="bool" /> for whether or not the two values are approximately equal.</returns>  
public static bool IsEqualApprox(float a, float b)  
{  
  if ((double) a == (double) b)  
    return true;  
  float num = 1E-06f * Mathf.Abs(a);  
  if ((double) num < 9.99999997475243E-07)  
    num = 1E-06f;  
  return (double) Mathf.Abs(a - b) < (double) num;  
}  
  
/// <summary>  
/// Returns whether <paramref name="s" /> is an infinity value (either positive infinity or negative infinity).  
/// </summary>  
/// <param name="s">The value to check.</param>  
/// <returns>A <see langword="bool" /> for whether or not the value is an infinity value.</returns>  
public static bool IsInf(float s) => float.IsInfinity(s);  
  
/// <summary>  
/// Returns whether <paramref name="s" /> is a <c>NaN</c> ("Not a Number" or invalid) value.  
/// </summary>  
/// <param name="s">The value to check.</param>  
/// <returns>A <see langword="bool" /> for whether or not the value is a <c>NaN</c> value.</returns>  
public static bool IsNaN(float s) => float.IsNaN(s);  
  
/// <summary>  
/// Returns <see langword="true" /> if <paramref name="s" /> is approximately zero.  
/// The comparison is done using a tolerance calculation with <see cref="F:Godot.Mathf.Epsilon" />.  
/// /// This method is faster than using <see cref="M:Godot.Mathf.IsEqualApprox(System.Single,System.Single)" /> with one value as zero.  
/// </summary>  
/// <param name="s">The value to check.</param>  
/// <returns>A <see langword="bool" /> for whether or not the value is nearly zero.</returns>  
public static bool IsZeroApprox(float s) => (double) Mathf.Abs(s) < 9.99999997475243E-07;  
  
/// <summary>  
/// Linearly interpolates between two values by a normalized value.  
/// This is the opposite <see cref="M:Godot.Mathf.InverseLerp(System.Single,System.Single,System.Single)" />.  
/// </summary>  
/// <param name="from">The start value for interpolation.</param>  
/// <param name="to">The destination value for interpolation.</param>  
/// <param name="weight">A value on the range of 0.0 to 1.0, representing the amount of interpolation.</param>  
/// <returns>The resulting value of the interpolation.</returns>  
public static float Lerp(float from, float to, float weight) => from + (to - from) * weight;  
  
/// <summary>  
/// Linearly interpolates between two angles (in radians) by a normalized value.  
/// /// Similar to <see cref="M:Godot.Mathf.Lerp(System.Single,System.Single,System.Single)" />,  
/// but interpolates correctly when the angles wrap around <see cref="F:Godot.Mathf.Tau" />.  
/// </summary>  
/// <param name="from">The start angle for interpolation.</param>  
/// <param name="to">The destination angle for interpolation.</param>  
/// <param name="weight">A value on the range of 0.0 to 1.0, representing the amount of interpolation.</param>  
/// <returns>The resulting angle of the interpolation.</returns>  
public static float LerpAngle(float from, float to, float weight)  
{  
  float num1 = (float) (((double) to - (double) from) % 6.28318548202515);  
  float num2 = (float) (2.0 * (double) num1 % 6.28318548202515) - num1;  
  return from + num2 * weight;  
}  
  
/// <summary>  
/// Natural logarithm. The amount of time needed to reach a certain level of continuous growth.  
/// /// Note: This is not the same as the "log" function on most calculators, which uses a base 10 logarithm.  
/// </summary>  
/// <param name="s">The input value.</param>  
/// <returns>The natural log of <paramref name="s" />.</returns>  
public static float Log(float s) => (float) Math.Log((double) s);  
  
/// <summary>Returns the maximum of two values.</summary>  
/// <param name="a">One of the values.</param>  
/// <param name="b">The other value.</param>  
/// <returns>Whichever of the two values is higher.</returns>  
public static int Max(int a, int b) => a > b ? a : b;  
  
/// <summary>Returns the maximum of two values.</summary>  
/// <param name="a">One of the values.</param>  
/// <param name="b">The other value.</param>  
/// <returns>Whichever of the two values is higher.</returns>  
public static float Max(float a, float b) => (double) a > (double) b ? a : b;  
  
/// <summary>Returns the minimum of two values.</summary>  
/// <param name="a">One of the values.</param>  
/// <param name="b">The other value.</param>  
/// <returns>Whichever of the two values is lower.</returns>  
public static int Min(int a, int b) => a < b ? a : b;  
  
/// <summary>Returns the minimum of two values.</summary>  
/// <param name="a">One of the values.</param>  
/// <param name="b">The other value.</param>  
/// <returns>Whichever of the two values is lower.</returns>  
public static float Min(float a, float b) => (double) a < (double) b ? a : b;  
  
/// <summary>  
/// Moves <paramref name="from" /> toward <paramref name="to" /> by the <paramref name="delta" /> value.  
/// /// Use a negative <paramref name="delta" /> value to move away.  
/// </summary>  
/// <param name="from">The start value.</param>  
/// <param name="to">The value to move towards.</param>  
/// <param name="delta">The amount to move by.</param>  
/// <returns>The value after moving.</returns>  
public static float MoveToward(float from, float to, float delta) => (double) Mathf.Abs(to - from) <= (double) delta ? to : from + (float) Mathf.Sign(to - from) * delta;  
  
/// <summary>  
/// Returns the nearest larger power of 2 for the integer <paramref name="value" />.  
/// </summary>  
/// <param name="value">The input value.</param>  
/// <returns>The nearest larger power of 2.</returns>  
public static int NearestPo2(int value)  
{  
  --value;  
  value |= value >> 1;  
  value |= value >> 2;  
  value |= value >> 4;  
  value |= value >> 8;  
  value |= value >> 16;  
  ++value;  
  return value;  
}  
  
/// <summary>  
/// Converts a 2D point expressed in the polar coordinate  
/// system (a distance from the origin <paramref name="r" />  
/// and an angle <paramref name="th" />) to the cartesian  
/// coordinate system (X and Y axis).  
/// </summary>  
/// <param name="r">The distance from the origin.</param>  
/// <param name="th">The angle of the point.</param>  
/// <returns>A <see cref="T:Godot.Vector2" /> representing the cartesian coordinate.</returns>  
public static Vector2 Polar2Cartesian(float r, float th) => new Vector2(r * Mathf.Cos(th), r * Mathf.Sin(th));  
  
/// <summary>  
/// Performs a canonical Modulus operation, where the output is on the range [0, <paramref name="b" />).  
/// </summary>  
/// <param name="a">The dividend, the primary input.</param>  
/// <param name="b">The divisor. The output is on the range [0, <paramref name="b" />).</param>  
/// <returns>The resulting output.</returns>  
public static int PosMod(int a, int b)  
{  
  int num = a % b;  
  if (num < 0 && b > 0 || num > 0 && b < 0)  
    num += b;  
  return num;  
}  
  
/// <summary>  
/// Performs a canonical Modulus operation, where the output is on the range [0, <paramref name="b" />).  
/// </summary>  
/// <param name="a">The dividend, the primary input.</param>  
/// <param name="b">The divisor. The output is on the range [0, <paramref name="b" />).</param>  
/// <returns>The resulting output.</returns>  
public static float PosMod(float a, float b)  
{  
  float num = a % b;  
  if ((double) num < 0.0 && (double) b > 0.0 || (double) num > 0.0 && (double) b < 0.0)  
    num += b;  
  return num;  
}  
  
/// <summary>  
/// Returns the result of <paramref name="x" /> raised to the power of <paramref name="y" />.  
/// </summary>  
/// <param name="x">The base.</param>  
/// <param name="y">The exponent.</param>  
/// <returns><paramref name="x" /> raised to the power of <paramref name="y" />.</returns>  
public static float Pow(float x, float y) => (float) Math.Pow((double) x, (double) y);  
  
/// <summary>Converts an angle expressed in radians to degrees.</summary>  
/// <param name="rad">An angle expressed in radians.</param>  
/// <returns>The same angle expressed in degrees.</returns>  
public static float Rad2Deg(float rad) => rad * 57.29578f;  
  
/// <summary>  
/// Maps a <paramref name="value" /> from [<paramref name="inFrom" />, <paramref name="inTo" />]  
/// to [<paramref name="outFrom" />, <paramref name="outTo" />].  
/// </summary>  
/// <param name="value">The value to map.</param>  
/// <param name="inFrom">The start value for the input interpolation.</param>  
/// <param name="inTo">The destination value for the input interpolation.</param>  
/// <param name="outFrom">The start value for the output interpolation.</param>  
/// <param name="outTo">The destination value for the output interpolation.</param>  
/// <returns>The resulting mapped value mapped.</returns>  
public static float RangeLerp(  
  float value,  
  float inFrom,  
  float inTo,  
  float outFrom,  
  float outTo)  
{  
  return Mathf.Lerp(outFrom, outTo, Mathf.InverseLerp(inFrom, inTo, value));  
}  
  
/// <summary>  
/// Rounds <paramref name="s" /> to the nearest whole number,  
/// with halfway cases rounded towards the nearest multiple of two.  
/// </summary>  
/// <param name="s">The number to round.</param>  
/// <returns>The rounded number.</returns>  
public static float Round(float s) => (float) Math.Round((double) s);  
  
/// <summary>  
/// Returns the sign of <paramref name="s" />: <c>-1</c> or <c>1</c>.  
/// Returns <c>0</c> if <paramref name="s" /> is <c>0</c>.  
/// </summary>  
/// <param name="s">The input number.</param>  
/// <returns>One of three possible values: <c>1</c>, <c>-1</c>, or <c>0</c>.</returns>  
public static int Sign(int s) => s == 0 ? 0 : (s < 0 ? -1 : 1);  
  
/// <summary>  
/// Returns the sign of <paramref name="s" />: <c>-1</c> or <c>1</c>.  
/// Returns <c>0</c> if <paramref name="s" /> is <c>0</c>.  
/// </summary>  
/// <param name="s">The input number.</param>  
/// <returns>One of three possible values: <c>1</c>, <c>-1</c>, or <c>0</c>.</returns>  
public static int Sign(float s) => (double) s == 0.0 ? 0 : ((double) s < 0.0 ? -1 : 1);  
  
/// <summary>  
/// Returns the sine of angle <paramref name="s" /> in radians.  
/// </summary>  
/// <param name="s">The angle in radians.</param>  
/// <returns>The sine of that angle.</returns>  
public static float Sin(float s) => (float) Math.Sin((double) s);  
  
/// <summary>  
/// Returns the hyperbolic sine of angle <paramref name="s" /> in radians.  
/// </summary>  
/// <param name="s">The angle in radians.</param>  
/// <returns>The hyperbolic sine of that angle.</returns>  
public static float Sinh(float s) => (float) Math.Sinh((double) s);  
  
/// <summary>  
/// Returns a number smoothly interpolated between <paramref name="from" /> and <paramref name="to" />,  
/// based on the <paramref name="weight" />. Similar to <see cref="M:Godot.Mathf.Lerp(System.Single,System.Single,System.Single)" />,  
/// but interpolates faster at the beginning and slower at the end.  
/// </summary>  
/// <param name="from">The start value for interpolation.</param>  
/// <param name="to">The destination value for interpolation.</param>  
/// <param name="weight">A value representing the amount of interpolation.</param>  
/// <returns>The resulting value of the interpolation.</returns>  
public static float SmoothStep(float from, float to, float weight)  
{  
  if (Mathf.IsEqualApprox(from, to))  
    return from;  
  float num = Mathf.Clamp((float) (((double) weight - (double) from) / ((double) to - (double) from)), 0.0f, 1f);  
  return (float) ((double) num * (double) num * (3.0 - 2.0 * (double) num));  
}  
  
/// <summary>  
/// Returns the square root of <paramref name="s" />, where <paramref name="s" /> is a non-negative number.  
/// /// If you need negative inputs, use <see cref="T:System.Numerics.Complex" />.  
/// </summary>  
/// <param name="s">The input number. Must not be negative.</param>  
/// <returns>The square root of <paramref name="s" />.</returns>  
public static float Sqrt(float s) => (float) Math.Sqrt((double) s);  
  
/// <summary>  
/// Returns the position of the first non-zero digit, after the  
/// decimal point. Note that the maximum return value is 10,  
/// which is a design decision in the implementation.  
/// </summary>  
/// <param name="step">The input value.</param>  
/// <returns>The position of the first non-zero digit.</returns>  
public static int StepDecimals(float step)  
{  
  double[] numArray = new double[9]  
  {    0.9999,  
    0.09999,  
    0.009999,  
    0.0009999,  
    9.999E-05,  
    9.999E-06,  
    9.999E-07,  
    9.999E-08,  
    9.999E-09  
  };  
  double num1 = (double) Mathf.Abs(step);  
  double num2 = num1 - (double) (int) num1;  
  for (int index = 0; index < numArray.Length; ++index)  
  {    if (num2 >= numArray[index])  
      return index;  
  }  return 0;  
}  
  
/// <summary>  
/// Snaps float value <paramref name="s" /> to a given <paramref name="step" />.  
/// This can also be used to round a floating point number to an arbitrary number of decimals.  
/// </summary>  
/// <param name="s">The value to stepify.</param>  
/// <param name="step">The step size to snap to.</param>  
/// <returns>The snapped value.</returns>  
public static float Stepify(float s, float step) => (double) step != 0.0 ? Mathf.Floor((float) ((double) s / (double) step + 0.5)) * step : s;  
  
/// <summary>  
/// Returns the tangent of angle <paramref name="s" /> in radians.  
/// </summary>  
/// <param name="s">The angle in radians.</param>  
/// <returns>The tangent of that angle.</returns>  
public static float Tan(float s) => (float) Math.Tan((double) s);  
  
/// <summary>  
/// Returns the hyperbolic tangent of angle <paramref name="s" /> in radians.  
/// </summary>  
/// <param name="s">The angle in radians.</param>  
/// <returns>The hyperbolic tangent of that angle.</returns>  
public static float Tanh(float s) => (float) Math.Tanh((double) s);  
  
/// <summary>  
/// Wraps <paramref name="value" /> between <paramref name="min" /> and <paramref name="max" />.  
/// Usable for creating loop-alike behavior or infinite surfaces.  
/// If <paramref name="min" /> is <c>0</c>, this is equivalent  
/// to <see cref="M:Godot.Mathf.PosMod(System.Int32,System.Int32)" />, so prefer using that instead.  
/// </summary>  
/// <param name="value">The value to wrap.</param>  
/// <param name="min">The minimum allowed value and lower bound of the range.</param>  
/// <param name="max">The maximum allowed value and upper bound of the range.</param>  
/// <returns>The wrapped value.</returns>  
public static int Wrap(int value, int min, int max)  
{  
  int num = max - min;  
  return num == 0 ? min : min + ((value - min) % num + num) % num;  
}  
  
/// <summary>  
/// Wraps <paramref name="value" /> between <paramref name="min" /> and <paramref name="max" />.  
/// Usable for creating loop-alike behavior or infinite surfaces.  
/// If <paramref name="min" /> is <c>0</c>, this is equivalent  
/// to <see cref="M:Godot.Mathf.PosMod(System.Single,System.Single)" />, so prefer using that instead.  
/// </summary>  
/// <param name="value">The value to wrap.</param>  
/// <param name="min">The minimum allowed value and lower bound of the range.</param>  
/// <param name="max">The maximum allowed value and upper bound of the range.</param>  
/// <returns>The wrapped value.</returns>  
public static float Wrap(float value, float min, float max)  
{  
  float s = max - min;  
  return Mathf.IsZeroApprox(s) ? min : min + ((value - min) % s + s) % s;  
}  
  
/// <summary>Returns the amount of digits after the decimal place.</summary>  
/// <param name="s">The input value.</param>  
/// <returns>The amount of digits.</returns>  
public static int DecimalCount(float s) => Mathf.DecimalCount((Decimal) s);  
  
/// <summary>Returns the amount of digits after the decimal place.</summary>  
/// <param name="s">The input <see langword="decimal" /> value.</param>  
/// <returns>The amount of digits.</returns>  
public static int DecimalCount(Decimal s) => (int) BitConverter.GetBytes(Decimal.GetBits(s)[3])[2];  
  
/// <summary>  
/// Rounds <paramref name="s" /> upward (towards positive infinity).  
/// /// This is the same as <see cref="M:Godot.Mathf.Ceil(System.Single)" />, but returns an <see langword="int" />.  
/// </summary>  
/// <param name="s">The number to ceil.</param>  
/// <returns>The smallest whole number that is not less than <paramref name="s" />.</returns>  
public static int CeilToInt(float s) => (int) Math.Ceiling((double) s);  
  
/// <summary>  
/// Rounds <paramref name="s" /> downward (towards negative infinity).  
/// /// This is the same as <see cref="M:Godot.Mathf.Floor(System.Single)" />, but returns an <see langword="int" />.  
/// </summary>  
/// <param name="s">The number to floor.</param>  
/// <returns>The largest whole number that is not more than <paramref name="s" />.</returns>  
public static int FloorToInt(float s) => (int) Math.Floor((double) s);  
  
/// <summary>  
/// Rounds <paramref name="s" /> to the nearest whole number.  
/// /// This is the same as <see cref="M:Godot.Mathf.Round(System.Single)" />, but returns an <see langword="int" />.  
/// </summary>  
/// <param name="s">The number to round.</param>  
/// <returns>The rounded number.</returns>  
public static int RoundToInt(float s) => (int) Math.Round((double) s);  
  
/// <summary>  
/// Returns <see langword="true" /> if <paramref name="a" /> and <paramref name="b" /> are approximately  
/// equal to each other.  
/// The comparison is done using the provided tolerance value.  
/// If you want the tolerance to be calculated for you, use <see cref="M:Godot.Mathf.IsEqualApprox(System.Single,System.Single)" />.  
/// </summary>  
/// <param name="a">One of the values.</param>  
/// <param name="b">The other value.</param>  
/// <param name="tolerance">The pre-calculated tolerance value.</param>  
/// <returns>A <see langword="bool" /> for whether or not the two values are equal.</returns>  
public static bool IsEqualApprox(float a, float b, float tolerance) => (double) a == (double) b || (double) Mathf.Abs(a - b) < (double) tolerance;
	```